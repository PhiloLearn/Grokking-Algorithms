<div dir="rtl">

# مقدمه ای بر الگوریتم ها

## در این فصل: 

- شما یک پایه برای بقیه کتاب می گیرید.

- شما اولین الگوریتم جستجوی خود را می نویسید (جستجوی دودویی)[^1]

- یاد می گیرید که چگونه در مورد زمان اجرای یک الگوریتم صحبت کنید.(نشانگذاری Big O)[^2]

- شما با یک تکنیک رایج برای طراحی الگوریتم ها آشنا شدید.(بازگشت)


## مقدمه

الگوریتم مجموعه ای از دستورالعمل ها برای انجام یک کار است. هر قطعه کد را می‌توان یک الگوریتم نامید، اما این کتاب بخش‌های جالب‌تری را پوشش می‌دهد. من الگوریتم‌های این کتاب را برای گنجاندن انتخاب کردم زیرا سریع هستند، یا مسائل جالبی را حل می‌کنند یا هر دو. در اینجا برخی از نکات برجسته آورده شده است:

- فصل 1 در مورد جستجوی باینری صحبت می کند و نشان می دهد که چگونه یک الگوریتم می تواند سرعت کد شما را افزایش دهد. در یک مثال، تعداد گام‌های مورد نیاز از 4 میلیارد به 32 کاهش می‌یابد

- یک دستگاه GPS از الگوریتم‌های گراف [^3] (همانطور که در فصل‌های 6، 7 و 8 خواهید آموخت) برای محاسبه کوتاه‌ترین مسیر به مقصد استفاده می‌کند.

- می توانید از برنامه نویسی پویا (که در فصل 9 بحث شد) برای نوشتن یک الگوریتم الگوریتم که چکرز را بازی می کند استفاده کنید.

در هر مورد، الگوریتم را شرح می دهم و مثالی برای شما می زنم. سپس در مورد زمان اجرای الگوریتم در نماد Big O صحبت خواهم کرد و در نهایت، بررسی خواهم کرد که چه نوع مشکلات دیگری را می توان با همان الگوریتم حل کرد.

## آنچه در مورد عملکرد یاد خواهید گرفت

خبر خوب این است که اجرای هر الگوریتم در این کتاب احتمالاً به زبان مورد علاقه شما موجود است، بنابراین لازم نیست هر الگوریتم را خودتان بنویسید! اما اگر مبادلات را درک نکنید، این پیاده سازی ها بی فایده هستند. در این کتاب، مقایسه مبادلات بین الگوریتم‌های مختلف را یاد خواهید گرفت: آیا باید از مرتب‌سازی ادغامی استفاده کنید یا مرتب‌سازی سریع؟ آیا باید از آرایه یا لیست استفاده کنید؟ فقط استفاده از یک ساختار داده متفاوت می تواند تفاوت بزرگی ایجاد کند.

## آنچه در مورد حل مشکلات یاد خواهید گرفت

شما تکنیک هایی را برای حل مشکلاتی که ممکن است تا کنون از درک شما خارج بوده اند، یاد بگیرید. مثلا:

- اگر به ساخت بازی های ویدیویی علاقه دارید، می توانید یک سیستم Al بنویسید که کاربر را با استفاده از الگوریتم های نمودار دنبال کند.

- شما یاد خواهید گرفت که با استفاده از k-نزدیک ترین همسایه[^4] یک سیستم توصیه بسازید 

- برخی از مشکلات به موقع قابل حل نیستند! بخشی از این کتاب که در مورد مسائل NP کامل[^5] صحبت می کند به شما نشان می دهد که چگونه آن مشکلات را شناسایی کنید و الگوریتمی ارائه دهید که به شما پاسخ تقریبی می دهد.

به طور کلی، در پایان این کتاب، برخی از پرکاربردترین الگوریتم ها را خواهید شناخت. سپس می توانید از دانش جدید خود برای یادگیری الگوریتم های خاص تر برای هوش مصنوعی، پایگاه های داده و غیره استفاده کنید. یا می توانید در محل کار خود با چالش های بزرگ تری روبرو شوید.

>قبل از شروع این کتاب باید جبر اولیه را بدانید. به طور خاص، این تابع را در نظر بگیرید: f(x) = x × 2
>f(5)چیست؟ اگر پاسختان ۱۰ بود، آماده هستید.
>علاوه بر این، اگر با یک زبان برنامه نویسی آشنا باشید، این فصل (و این کتاب) راحت تر خواهد بود. تمامی نمونه های این کتاب به زبان پایتون هستند. اگر هیچ زبان برنامه نویسی نمی دانید و می خواهید یکی را یاد بگیرید، پایتون را انتخاب کنید – برای مبتدیان عالی است. اگر زبان دیگری مانند روبی بلد باشید، خوب خواهید بود.

## جستوجو باینری

![teacher](../images/01/teacher.jpg)

فرض کنید در دفترچه تلفن به دنبال شخصی هستید (چه جمله قدیمی!). نام آنها با ض شروع می شود. می توانید از ابتدا شروع کنید و تا زمانی که به ض برسید به ورق زدن صفحات ادامه دهید. اما به احتمال زیاد از یک صفحه در وسط شروع می‌کنید، زیرا می‌دانید که ض نزدیک به وسط دفترچه تلفن خواهد بود.

یا فرض کنید در حال جستجوی کلمه ای در فرهنگ لغت هستید و با ط  شروع می شود. باز هم، نزدیک به وسط شروع می کنید.

حالا فرض کنید وارد فیس بوک شده اید. وقتی این کار را انجام می دهید، فیس بوک باید تأیید کند که شما یک حساب در سایت دارید. بنابراین، باید نام کاربری شما را در پایگاه داده خود جستجو کند. فرض کنید نام کاربری شما karlmageddon است. فیس بوک می تواند از Aها شروع کند  و نام شما را جستجو کند - اما منطقی تر است که از جایی در وسط شروع کند.

این یک مشکل جستجو است. و همه این موارد از یک الگوریتم برای حل مشکل استفاده می کنند: جستجوی باینری.

![Someone is watching the monitor](../images/01/monitor.jpg)

جستجوی باینری یک الگوریتم است. ورودی آن یک لیست مرتب شده از عناصر است (بعدا توضیح خواهم داد که چرا باید مرتب شود). اگر عنصری که به دنبال آن هستید در آن لیست باشد، جستجوی باینری موقعیتی را که در آن قرار دارد برمی‌گرداند. در غیر این صورت، جستجوی دودویی صفر برمی‌گرداند.

مثلا:

![example](../images/01/binary_search_00.jpg)

به دنبال شرکت هایی در دفترچه تلفن با جستجوی باینری هستید

در اینجا مثالی از نحوه عملکرد جستجوی باینری آورده شده است. من به عددی بین 1 تا 100 فکر می کنم.

![binary_search_01](../images/01/binary_search_01.jpg)

شما باید سعی کنید شماره من را در کمترین تلاش ممکن حدس بزنید. با هر حدس، به شما خواهم گفت که حدس شما خیلی کم، خیلی زیاد یا درست است.
فرض کنید شروع به حدس زدن به این صورت کردید: 1، 2، 3، 4 .... در اینجا چگونه پیش خواهد رفت.

![binary_search_02](../images/01/binary_search_02.jpg)

**رویکرد بد برای حدس زدن اعداد**

این جستجوی ساده است (شاید جستجوی احمقانه اصطلاح بهتری باشد). با هر حدس، فقط یک عدد را حذف می کنید. اگر شماره من 99 بود، 99 حدس زدن طول می کشد تا به آنجا برسید!

---

### روشی بهتر برای جستجو

تکنیک بهتری هم وجود دارد. با 50 شروع کنید.

![binary_search_03](../images/01/binary_search_03.jpg)

خیلی کم است، اما شما نیمی از اعداد را حذف کردید! اکنون می دانید که اعداد 1 تا 50 بسیار کم هستند. حدس بعدی: 75.

![binary_search_04](../images/01/binary_search_04.jpg)

خیلی بالاست، اما دوباره نصف اعداد باقیمانده را کاهش دادید! با جستجوی باینتری، شما عدد وسط را حدس می زنید و هر بار نیمی از اعداد باقی مانده را حذف می کنید. بعدی 63 است (نیمه راه بین 50 تا 75).

![binary_search_05](../images/01/binary_search_05.jpg)

این جستجو باینری است. شما به تازگی اولین الگوریتم خود را یاد گرفتید! در اینجا آمده است که هر بار چند عدد را می توانید حذف کنید.

![binary_search_06](../images/01/binary_search_06.jpg)

**هر بار با جستجوی باینری نیمی از اعداد را حذف کنید.**

به هر عددی که فکر می کنم، می توانید حداکثر با هفت مرحله آن را حدس بزنید - زیرا با هر حدس زدن تعداد زیادی اعداد را حذف می کنید!
فرض کنید به دنبال کلمه ای در فرهنگ لغت هستید. فرهنگ لغت دارای 240000 کلمه است. در بدترین حالت، فکر می کنید هر جستجو چند مرحله را طی می کند؟

![binary_search_07](../images/01/binary_search_07.jpg)

اگر کلمه مورد نظر شما آخرین کلمه در کتاب باشد، جستجوی ساده می‌تواند 240000 مرحله انجام دهد. با هر مرحله از جستجوی باینری، تعداد کلمات را به نصف کاهش می دهید تا زمانی که تنها یک کلمه باقی بماند.

![binary_search_08](../images/01/binary_search_08.jpg)

بنابراین جستجوی باینری 18 مرحله خواهد داشت - یک تفاوت بزرگ! به طور کلی، برای هر لیستی از n، جستجوی باینری در بدترین حالت log~2~n مرحله انجام می دهد، در حالی که جستجوی ساده n مرحله را انجام می دهد.



</div>

[^1]: binary search
[^2]: Big O notation
[^3]: graph algorithms 
[^4]: k-Nearest Neighbors
[^5]: NP-complete 